const axios = require('axios');
const constants = require('./constants');
const path = require('path');
const { dirname } = require('path');
const fs = require('fs');
const Joi = require('joi');
const { XMLValidator } = require('fast-xml-parser');
const Encoding = require('encoding-japanese');

/**
 * object that contains to allow encodings
 * @type {{ASCII: string}}
 */
const validEncodings = {
    ASCII: 'ASCII',
    BINARY: 'BINARY',
    SJIS: 'SJIS',
    UNICODE: 'UNICODE',
    UTF8: 'UTF8'
};

/**
 * Method for convert the following encodings to utf8 without validations
 * ascii
 * binary
 * latin1
 * utf8
 * utf-8
 * @param text
 * @returns {string}
 */
const _convertToUtf8 = (text) => Buffer.from(text, 'utf8').toString();

/**
 * Method for convert the base4 encoding to utf8
 * @param text
 * @returns {string}
 */
const convertBase64ToUtf8 = (text) => Buffer.from(text, 'base64').toString();

/**
 * Method for convert the base46url encoding to utf8
 * @param text
 * @returns {string}
 */
const convertBase64UrlToUtf8 = (text) => Buffer.from(text, 'base64url').toString();

/**
 * Method for convert the base46url encoding to utf8
 * @param text
 * @returns {string}
 */
const convertUtf8ToBase64 = (text) => Buffer.from(text).toString('base64');

/**
 * Method to convert any parameter as object or array
 * @param param
 * @returns {{}|any}
 */
function convertToObject(param) {
    let result = param;
    if (!param) return {};
    if (Array.isArray(param)) return param;
    if (!validEncodings[Encoding.detect(param)]) throw Error(constants.ERROR_CONVERT_ENCODING);
    if (validateHex(param)) throw Error(constants.ERROR_CONVERT_ENCODING);
    if (_isObjectValid(param)) return param;
    if (_isObject(param)) return param;
    if (validateBase64(param)) {
        result = convertBase64ToUtf8(param);
        if (!result) {
            result = convertBase64UrlToUtf8(param);
        }
    } else if (Buffer.isBuffer(param)) {
        result = _convertToUtf8(param);
    }
    try {
        result = _convertToUtf8(result);
        return JSON.parse(result);
    } catch (e) {
        try {
            result = _convertToUtf8(result);
            return JSON.parse(JSON.stringify(result));
        } catch (e) {
            throw Error(constants.ERROR_CONVERT_ENCODING)
        }
    }
}

/**
 * Method for convert the following encodings to utf8
 * ascii
 * binary
 * latin1
 * utf8
 * utf-8
 * @param text
 * @returns {string}
 */
const convertToUtf8 = (text) => {
    if (!text) throw Error(constants.ERROR_CONVERT_ENCODING);
    if (!validEncodings[Encoding.detect(text)]) throw Error(constants.ERROR_CONVERT_ENCODING);
    if (validateHex(text)) throw Error(constants.ERROR_CONVERT_ENCODING);
    if (typeof text === 'string') {
        if (validateBase64(text)) {
            let result = convertBase64ToUtf8(text);
            if (result) {
                return result;
            }
            return convertBase64UrlToUtf8(text);
        } else if (_isObjectValid(text)) {
            return text;
        } else {
            return _convertToUtf8(text);
        }
    } else if (_isObjectValid(text)) {
        return text;
    } else {
        return _convertToUtf8(text);
    }
};

/**
 * Remove File
 * @param uploadPath
 * @returns {boolean}
 */
const deleteFile = async (uploadPath) => {
    if (fs.existsSync(uploadPath)) {
        try {
            fs.rmSync(uploadPath);
            return true;
        } catch (e) {
            throw Error(e);
        }
    }
};

/**
 * Method for create a directory
 * @param directory
 * @param rootPath
 * @returns {string|boolean}
 */
const helperDirectory = (directory = '', rootPath = false) => {
    if (!directory)
        return false;
    let _rootPath = rootPath ? path.join(dirname(require.main.filename), directory)
        : path.join(__dirname, directory);
    if (!fs.existsSync(_rootPath))
        fs.mkdirSync(_rootPath, { recursive: true });
    return _rootPath;
};

/**
 * Method for validate if any parameter is an object
 * @param param
 * @returns {boolean}
 * @private
 */
const _isObject = (param) => {
    if (Array.isArray(param))
        return true
    return Object.getPrototypeOf(param) === Object.prototype;
}

/**
 * Method for validate if any parameter is an object
 * @param param
 * @returns {boolean}
 */
const isObject = (param) => {
    if (!param) return false;
    if (Array.isArray(param) /*&& param.length > 0*/) return true;
    if (!validEncodings[Encoding.detect(param)]) return false;
    if (validateHex(param)) return false;
    try {
        if (typeof param === 'string') {
            if (validateBase64(param)) {
                if (_isObject(JSON.parse(convertBase64ToUtf8(param)))) {
                    return true;
                }
                return _isObject(JSON.parse(convertBase64UrlToUtf8(param)));
            } else {
                let obj = JSON.parse((_convertToUtf8(param)));
                return obj === Object(obj);
                //return obj === Object(obj) && Object.prototype.toString.call(obj) !== '[object Array]';
                //return (typeof Object(JSON.parse(JSON.stringify(convertToUtf8(param)))) === "object");
            }
        } else if (Buffer.isBuffer(param)) {
            return _isObject(JSON.parse(_convertToUtf8(param)));
        } else {
            return _isObject(param);
        }
    } catch (e) {
        return false;
    }
};

/**
 * Method for validate if any parameter is an object, and it's not empty
 * @param param
 * @returns {boolean}
 * @private
 */
const _isObjectValid = (param) => {
    if (Array.isArray(param))
        return true;
    return Object.getPrototypeOf(param) === Object.prototype && Object.keys(param).length > 0;
};

/**
 * Method for validate if any parameter is an object, and it's not empty
 * @param param
 * @returns {boolean}
 */
const isObjectValid = (param) => {
    if (!param) return false;
    if (Array.isArray(param) /*&& param.length > 0*/) return true;
    if (!validEncodings[Encoding.detect(param)]) return false;
    if (validateHex(param)) return false;
    try {
        if (typeof param === 'string') {
            if (validateBase64(param)) {
                if (_isObjectValid(convertBase64ToUtf8(param))) {
                    return true;
                }
                return _isObjectValid(JSON.parse(convertBase64UrlToUtf8(param)));
            } else {
                let obj = JSON.parse((_convertToUtf8(param)));
                return obj === Object(obj) && Object.keys(obj).length > 0;
            }
        } else if (Buffer.isBuffer(param)) {
            return _isObjectValid(JSON.parse(_convertToUtf8(param)));
        } else {
            return _isObjectValid(param);
        }
    } catch (e) {
        return false;
    }
};

/**
 * This function creates a random number used when a queue can't be defined
 * @returns {string}
 */
function randomNum() {
    return Math.random().toString().split(".")[1].substring(0, 8);
}

/**
 * Method for remove customTimeZone, thi remove is only on memory
 */
const removeCustomTimeZone = () => {
    delete process.env['TZ'];
};

/**
 * Save File
 * @param properties
 * @param base64
 * @returns {String}
 */
const saveFile = (properties, base64 = true) => {
    const { file, content } = properties;
    const rootPath = helperDirectory('uploads');
    const uploadPath = path.join(rootPath, file);
    try {
        const encoding = base64 ? 'base64' : 'utf8';
        fs.writeFileSync(uploadPath, content, { encoding });
        return uploadPath;
    } catch (e) {
        throw Error(e);
    }
};

/**
 * Method for set TimeZone in env system, this env system only create on memory
 * @param text
 */
const setTimeZone = (text) => {
    process.env['TZ'] = text;
};

/**
 * Method for valid properties
 * @param properties
 * @param data
 * @param cfg
 * @param optional
 * @returns {boolean}
 */
const validProperties = (properties = {}, data = {}, cfg = {}, optional = false) => {
    Object.keys(properties).forEach((value) => {
        if (data.hasOwnProperty(value) && data[value] !== null) {
            properties[value] = data[value];
        } else if (cfg.hasOwnProperty(value) && cfg[value] !== null) {
            properties[value] = cfg[value];
        } else {
            if (optional)
                properties[value] = properties[value];
            else
                throw Error(`${constants.ERROR_PROPERTY} ${value}`);
        }
    });
    return true;
};

/**
 * Method to validate is parameter is base64 format or base64url format
 * @param value
 * @returns {boolean}
 */
function validateBase64(value) {
    if (!value) return false;
    if (!validEncodings[Encoding.detect(value)]) throw Error(constants.ERROR_CONVERT_ENCODING);
    if (validateHex(value)) throw Error(constants.ERROR_CONVERT_ENCODING);
    const Base64 = Joi.string().base64({ paddingRequired: false, urlSafe: true });
    const Base64u = Joi.string().base64({ paddingRequired: true, urlSafe: false });
    const { error: e } = Base64.validate(value);
    if (!e) return true;
    const { error } = Base64u.validate(value);
    return !error;
}

/**
 * validate if value is hexadecimal encoding
 * @param value
 * @returns {boolean}
 */
function validateHex(value) {
    if (!value) return false;
    let hex = Joi.string().hex({ byteAligned: true });
    let hex2 = Joi.string().hex({ byteAligned: false });
    const { error: e } = hex.validate(value);
    if (!e) return true;
    const { error } = hex2.validate(value);
    return !error;
}

/**
 * Method to validate XML structure
 * @param text
 * @returns {boolean|boolean|{err: {code: string, msg: string, line: number, col: number}}}
 */
const validateXMLStructure = (text) => {
    if (!text) return false;
    let result;
    if (validateBase64(text)) {
        result = XMLValidator.validate(convertBase64ToUtf8(text), { allowBooleanAttributes: true });
        if (_isObjectValid(result))
            return false;
        result = XMLValidator.validate(convertBase64UrlToUtf8(text), { allowBooleanAttributes: true });
    } else
        result = XMLValidator.validate(_convertToUtf8(text), { allowBooleanAttributes: true });
    if (_isObjectValid(result))
        return false;
    return result;
};

/**
 * Method to create chunks from a buffer
 * @param content
 * @param maxBytes
 * @returns {Array}
 */
function chunk(content, maxBytes) {
    let buf = Buffer.from(content);
    const result = [];
    while (buf.length) {
        let i = buf.lastIndexOf(32, maxBytes + 1);
        // If no space found, try forward search
        if (i < 0) i = buf.indexOf(32, maxBytes);
        // If there's no space at all, take the whole string
        if (i < 0) i = buf.length;
        // This is a safe cut-off point; never half-way a multi-byte
        result.push(buf.subarray(0, i).toString());
        buf = buf.subarray(i + 1); // Skip space (if any)
    }
    return result;
}

/**
 * Method to obtain the name of a workflow
 * @param properties The properties to use OIH APIs and get the workflow name
 * @param workflowID The id of the desired workflow to get its name
 * @param token A token to connect to the OIH APIs
 * @returns workflowName
 */
async function getWorkflowName(properties, workflowID = null, token = null) {
    let props = {
        FLOWS_OIH: null,
        IAM_OIH: null,
        IAM_OIH_PWS: null,
        IAM_OIH_USER: null
    }
    let workflowName = null;

    const valid = validProperties(props, {}, properties);

    if (valid) {
        if (!token) {
            const { data } = await axios(
                {
                    method: 'POST',
                    url: props.IAM_OIH,
                    data: {
                        "password": props.IAM_OIH_PWS,
                        "username": props.IAM_OIH_USER
                    }
                }
            );
            token = data.token;
        }

        if (!workflowID) {
            if (constants.ELASTICIO_LISTEN_MESSAGES_ON) {
                let tempFullID = constants.ELASTICIO_LISTEN_MESSAGES_ON.split(':');
                if (tempFullID) {
                    workflowID = `${tempFullID[0]}`.substring(5);
                }
            }
        }

        axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        const { data } = await axios(
            {
                method: 'GET',
                url: `${props.FLOWS_OIH}${workflowID}`
            }
        );
        workflowName = data.data.name ? data.data.name : null;

        return workflowName;
    }
}

/**
 * Method to obtain the step_name from a step_id in a workflow
 * @param properties The properties to use OIH APIs and get the workflow name
 * @param workflowID The id of the desired workflow to get its name
 * @param token A token to connect to the OIH APIs
 * @returns workflowName
 */
async function getStepName(properties, workflowID = null, stepId, token = null) {
    let props = {
        FLOWS_OIH: null,
        IAM_OIH: null,
        IAM_OIH_PWS: null,
        IAM_OIH_USER: null
    }
    let stepName = null;

    const valid = validProperties(props, {}, properties);

    if (valid) {
        if (!token) {
            const { data } = await axios(
                {
                    method: 'POST',
                    url: props.IAM_OIH,
                    data: {
                        "password": props.IAM_OIH_PWS,
                        "username": props.IAM_OIH_USER
                    }
                }
            );
            token = data.token;
        }

        if (!workflowID) {
            if (constants.ELASTICIO_LISTEN_MESSAGES_ON) {
                let tempFullID = constants.ELASTICIO_LISTEN_MESSAGES_ON.split(':');
                if (tempFullID) {
                    workflowID = `${tempFullID[0]}`.substring(5);
                }
            }
        }

        axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        const { data } = await axios(
            {
                method: 'GET',
                url: `${props.FLOWS_OIH}${workflowID}`
            }
        );

        for (let node of data.data.graph.nodes) {
            if (node.id === stepId) {
                stepName = node.name;
            }
        }

        return stepName;
    }
}

function getConnectorProps() {
    let properties = {
        FLOWS_OIH: constants.FLOWS_OIH,
        IAM_OIH: constants.IAM_OIH,
        IAM_OIH_PWS: constants.IAM_OIH_PWS,
        IAM_OIH_USER: constants.IAM_OIH_USER,
        URI_RABBITMQ: constants.URI_RABBITMQ,
        api_url: process.env.ELASTIC_SEARCH,
        auth: `Basic ${process.env.ELASTIC_SEARCH_AUTH}`,
        method: 'POST'
    };

    return properties;
}

/**
 * Method to replace all configuration variables
 * @param object The object that requires to update configuration variables
 * @param configurations the list of configuration variables with required value to be set
 * @returns object
 */
function replaceConfigVars(object, configurations) {
    if (isObjectValid(object)) {
        object = JSON.stringify(object);

        Object.keys(configurations).forEach(_config => {
            if (object.includes(`%${_config}%`)) {
                object = object.replaceAll(`%${_config}%`, configurations[_config]);
            }
        });

        object = convertToObject(object);
    } else if (typeof object === "string") {
        Object.keys(configurations).forEach(_config => {
            if (object.includes(`%${_config}%`)) {
                object = object.replaceAll(`%${_config}%`, configurations[_config]);
            }
        });
    }

    return object;
}

async function getQuickData({ flowId, flowExecId}) {
    try {
      const response = await axios({
        method: 'GET',
        url:  constants.GQD_API,
        data: 
          {
            flowId: flowId,
            flowExecId:flowExecId
          }
        
      })
        return response.data;
    } catch (e) {
      console.error(e);
      return { exists: false };
    }
  }

  async function insQuickData({ flowId, flowExecId,stepId,stepOutput,configuration}) {
    try {
      const response = await axios({
        method: 'POST',
        url:  constants.IQD_API,
        data: 
          {
            flowId: flowId,
            flowExecId:flowExecId,
            stepId:stepId,
            stepOutput:stepOutput,
            configuration:configuration
          }
        
      })
        return response.data;
    } catch (e) {
      console.error(e);
      return { exists: false };
    }
  }

module.exports = {
    convertBase64ToUtf8,
    convertToObject,
    convertToUtf8,
    chunk,
    deleteFile,
    getWorkflowName,
    getConnectorProps,
    getStepName,
    helperDirectory,
    isObject,
    isObjectValid,
    randomNum,
    removeCustomTimeZone,
    replaceConfigVars,
    saveFile,
    setTimeZone,
    validProperties,
    validateBase64,
    validateHex,
    validateXMLStructure,
    getQuickData,
    insQuickData
};
